if ...~="-api" then
  term.clear()
  term.setCursorPos(1,1)
end
system = {}
if ...=="-safe" then 
  system.safemode=true
  print("Safemode active.") 
end 

table.indexOf = function(tab, key)
  for k, v in pairs(tab) do
    if v==key then return k end
  end
end
function system.drawMenu(m, pt, n, k)
  pt=pt or ""
  n=n or 1
  k=k or {28}
  local s,h = term.getSize()
  h=h-2-print(pt)
  if n<h then
    s=1
  elseif n>(#m-h+1) then
    s=#m-h+1
  else
    s=n-h
  end
  while true do
    term.clear()
    term.setCursorPos(1,1)
    print(pt)
    for i=s,s+h do
      if i==n then 
        print("-> ["..m[i].."]")
      else 
        print(m[i])
      end 
      if #m==i then break end
    end
    local _,key = os.pullEvent("key")
    if key == 200 and n>1 then 
      n=n-1
      if n<s then s=s-1 end
    elseif key == 208 and n<#m then 
      n=n+1
      if s<#m-h+1 and n>s+h then s=s+1 end
    elseif table.indexOf(k, key) then return n, key end
  end 
end
function system.writeCenter(text)
  local w = term.getSize()
  if #text>w then
    system.writeCenter(string.sub(text, 1, #text/2))
    print()
    system.writeCenter(string.sub(text, (#text/2)-1))
  else
    local _, h = term.getCursorPos()
    term.setCursorPos((w/2)-(#text/2), h)
    write(text)
  end
end

--Probably not the best name for it...
if settings.get("SimOS.UEFI") then
  local drives = {peripheral.find("drive", function(side) return disk.hasData(side) and fs.exists(disk.getMounthPath(side).."/startup") end)}
  dp = {{"shell exit", ""},{"Run SimOS", "Exit to shell"}}
  for i=1, #drives do
    table.insert(dp[1], drives[i].getMountPath().."/startup")
    if drives[i].getDiskLabel() then
      table.insert(dp[2], drives[i].getDiskLabel().."(disk ID:"..drives[i].getDiskID()..")")
    else
      table.insert(dp[2],"Unlabeled disk (ID:"..drives[i].getDiskID()..")")
    end
  end
  if #dp[2]>2 then
    local n = system.drawMenu(dp[2], "Multiple boot devices found. Please select one:\n")
    if n==2 then return end
    os.run({["shell"]=shell,["multishell"]=multishell}, dp[1][n]) 
  end
end

system.mainFile = "/"..shell.getRunningProgram()
system.dir = "/"..fs.combine(system.mainFile, "..")

if ...~="-api" then
  --I'm too lazy to implement missing log file handling properly
  fs.open(system.dir.."/SimOS.log", "a").close()
  local lines = {}
  for l in io.lines(system.dir.."/SimOS.log") do
    table.insert(lines, l)
  end
  while #lines>512 do
    table.remove(lines, 1)
  end
  local log = fs.open(system.dir.."/SimOS.log", "w")
  log.writeLine(table.concat(lines, "\n").."\n--BREAK--")
  function system.log(event)
    log.writeLine("["..os.clock().."]"..tostring(event))
    log.flush()
  end
  system.log("SimOS started in "..system.dir.." on "..os.day().." at "..textutils.formatTime(os.time()))
end

fs.delete(system.dir.."/tmp")
local h = fs.open(system.dir.."/tmp/.ignoreme", "w")
h.write("This directory is used to implement io.tmpfile.\nAnything in this directory will be deleted when SimOS starts.\nThis file is here to make sure Git syncs the folder.")
h.close()
function io.tmpfile(name, del)
  name = name or ""
  local i = 0
  repeat
    i=i+1
  until not fs.exists(system.dir.."/tmp/"..name.."temp"..i)
  local file = fs.open(system.dir.."/tmp/"..name.."temp"..i, "w")
  if not del then
    local oldclose = file.close
    file.close = function()
      oldclose()
      fs.delete(system.dir.."/tmp/"..name.."temp"..i)
    end
  end 
  return file, (system.dir.."/tmp/"..name.."temp"..i) 
end

function bit.tobits(num)
  local tab, new = {}
  for i=0, 31 do
    new = bit.blshift(num, i)
    table.insert(tab, bit.blogic_rshift(new, 31))
  end
  while tab[1]==0 do
    table.remove(tab,1)
  end
  return tab
end
function bit.tonum(bits)
  local num = 0
  for i=1, #bits do
    if bits[i]==1 then
      num = num + 2^(#bits-i)
    end
  end
  return num
end

function system.waitForKey(n)
  while true do
    local _,key = os.pullEvent("key")
    if key==n then return end 
  end 
end
if system.safemode then system.log("Running in safemode.") end

if ...~="-api" then
  if not ... then
  	local h = paintutils.loadImage(system.dir.."/logo")
  	for i=-9, 2 do
  	  sleep(0.1)
  	  term.clear()
  	  paintutils.drawImage(h, 2, i)
  	  term.setBackgroundColor(0x8000)
      term.setTextColor(1)
      system.writeCenter("by jlortiz\n\n")
  	end
  end
  print("Press SHIFT to pause startup...")
  if parallel.waitForAny(function() system.waitForKey(42) end, function() system.waitForKey(54) end, function() sleep(3) end)~=3 then
    system.log("User entered advanced startup menu.")
    local n = system.drawMenu({"Continue boot","Start in safemode", "Exit to CraftOS", "Shutdown"}, "Startup paused.\n")
    if n==4 then os.shutdown()
    else
      if n == 1 then shell.run(system.mainFile) 
      elseif n==2 then shell.run(system.mainFile, "-safe") end
	  system.log("Now exiting...")
      return
    end 
  end
else system.safemode = true
end

h = fs.open(system.dir.."/registry", "r")
local registry = textutils.unserialise(h.readAll())
h.close()
local pass = registry.apass
function system.get(value)
  return textutils.unserialize(textutils.serialize(registry[value]))
end
function system.set(value, new)
  registry[value]=textutils.unserialize(textutils.serialize(new))
end
function system.saveSettings()
  local h = fs.open(system.dir.."/registry", "w")
  h.write(textutils.serialise(registry))
  h.close()
  system.log("Saved registry.")
end

if not system.safemode then
  term.clear()
  term.setCursorPos(1,1)
  for _,v in pairs(fs.list(system.dir.."/startup/")) do
    if not shell.run("/"..system.dir.."/startup/"..v) then
      system.log("Startup script error! File: "..system.dir.."/startup/"..v)
    end
  end
end
if ...=="-api" or system.safemode=="exit" then return end
if ...=="-panic" then os=false end

local function main()
  local n=1
  while true do
    local progs = system.get("programs")
    local active = {}
    for i=1,#progs do
      table.insert(active, progs[i][1])
    end
    table.insert(active, "Exit")
      n = system.drawMenu(active, "Welcome to SimOS.\nIt is "..textutils.formatTime(os.time(), system.get("24hr")).." on day "..os.day()..".\n", n)
    if n == #active then
      local n=system.drawMenu({"Cancel", "Exit to CraftOS", "Reboot", "Shutdown"}, "Shutdown Menu:\n")
	  if n>1 then system.log("We are now exiting...") end
      if n==4 then os.shutdown()
      elseif n==3 then os.reboot()
      elseif n==2 then return end
    else
      system.log("User running "..progs[n][2])
      term.clear()
      term.setCursorPos(1,1)
      local dir = shell.dir()
      shell.setDir(system.dir.."/programs/")
      shell.run(progs[n][2])
      shell.setDir(dir)
      system.log("Returning to SimOS main menu...")
      sleep(system.get("endwait"))
    end 
  end
end

while true do
  local ok, error = pcall(main)
  if not ok then
   if not (os and load and loadfile and fs) then
      term.clear()
      term.setCursorPos(1,1)
      print("KERNEL PANIC!")
      print("Cannot access OS API.")
      print("Cannot recover from this error.")
      print("Unsafe to run shell.")
      print("We are hanging here, hold Ctrl+R to reboot...")
      while true do coroutine.yield() end
    end
    if not system then
	  if shell then
        os.run({["shell"]=shell},shell.getRunningProgram(), "-api")
	  else
	    print("Fatal SimOS error: "..error)
		print("Could not load the proper error handler, exiting...")
		print("You will have to log this manually.")
		return
	  end
    end
    system.log("Fatal SimOS error! "..error)
    local p
    if error=="Terminated" then
      p="What, you thought you could escape this easily? \nHAHAHAHAHAHAHAHAHA!"
    else
      p = "Sorry, but SimOS has encountered an error and must close.\nThe error is as follows:\n"..error
    end
    if system.drawMenu({"Attempt restart", "Exit to shell"}, p)==2 then
      break
   end
  else
    break
  end
end
