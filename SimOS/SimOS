if ...~="-api" then
  term.clear()
  term.setCursorPos(1,1)
end
system = {}
if ...=="-safe" then 
  system.safemode=true
  print("Safemode active.") 
end 

table.indexOf = function(tab, key)
  for k, v in pairs(tab) do
    if v==key then return k end
  end
end
function system.drawMenu(m, pt, n, k)
  pt=pt or ""
  n=n or 1
  k=k or {28}
  local s,h = term.getSize()
  h=h-2-print(pt)
  if n<h then
    s=1
  elseif n>(#m-h+1) then
    s=#m-h+1
  else
    s=n-h
  end
  while true do
    term.clear()
    term.setCursorPos(1,1)
    print(pt)
    for i=s,s+h do
      if i==n then 
        print("-> ["..m[i].."]")
      else 
        print(m[i])
      end 
      if #m==i then break end
    end
    local _,key = os.pullEvent("key")
    if key == 200 and n>1 then 
      n=n-1
      if n<s then s=s-1 end
    elseif key == 208 and n<#m then 
      n=n+1
      if s<#m-h+1 and n>s+h then s=s+1 end
    elseif table.indexOf(k, key) then return n, key end
  end 
end
function system.writeCenter(text)
  local w = term.getSize()
  if #text>w then
    system.writeCenter(string.sub(text, 1, #text/2))
    print()
    system.writeCenter(string.sub(text, (#text/2)-1))
  else
    local _, h = term.getCursorPos()
    term.setCursorPos((w/2)-(#text/2), h)
    write(text)
  end
end

--Probably not the best name for it...
if settings.get("SimOS.UEFI") then
  local drives = {peripheral.find("drive", disk.hasData)}
  dp = {{"shell exit", ""},{"Run SimOS", "Exit to shell"}}
  for i=1, #drives do
    if fs.exists(drives[i].getMountPath().."/startup") then
      table.insert(dp[1], drives[i].getMountPath().."/startup")
      if drives[i].getDiskLabel() then
        table.insert(dp[2], drives[i].getDiskLabel().."(disk ID:"..drives[i].getDiskID()..")")
      else
        table.insert(dp[2],"Unlabeled disk (ID:"..drives[i].getDiskID()..")")
      end
    end
  end
  if #dp[2]>2 then
    local n = system.drawMenu(dp[2], "Multiple boot devices found. Please select one:\n")
    if n==2 then return end
    os.run({["shell"]=shell,["multishell"]=multishell}, dp[1][n]) 
  end
end

system.mainFile = "/"..shell.getRunningProgram()
system.dir = "/"..fs.combine(system.mainFile, "..")

if ...~="-api" then
  local lines = {}
  for l in io.lines(system.dir.."/SimOS.log") do
    table.insert(lines, l)
  end
  while #lines>512 do
    table.remove(lines, 1)
  end
  local log = fs.open(system.dir.."/SimOS.log", "w")
  log.writeLine(table.concat(lines, "\n").."\n--BREAK--")
  function system.log(event)
    log.writeLine("["..os.clock().."]"..tostring(event))
    log.flush()
  end
  system.log("SimOS started in "..system.dir.." on "..os.day().." at "..textutils.formatTime(os.time()))
end

fs.delete(system.dir.."/tmp")
local h = fs.open(system.dir.."/tmp/.ignoreme", "w")
h.write("This directory is used to implement io.tmpfile.\nAnything in this directory will be deleted when SimOS starts.\nThis file is here to make sure Git syncs the folder.")
h.close()
function io.tmpfile(name, del)
  name = name or ""
  local i = 0
  repeat
    i=i+1
  until not fs.exists(system.dir.."/tmp/"..name.."temp"..i)
  local file = fs.open(system.dir.."/tmp/"..name.."temp"..i, "w")
  if not del then
    local oldclose = file.close
    file.close = function()
      oldclose()
      fs.delete(system.dir.."/tmp/"..name.."temp"..i)
    end
  end 
  return file, (system.dir.."/tmp/"..name.."temp"..i) 
end

function bit.tobits(num)
  local tab, new = {}
  for i=0, 31 do
    new = bit.blshift(num, i)
    table.insert(tab, bit.blogic_rshift(new, 31))
  end
  while tab[1]==0 do
    table.remove(tab,1)
  end
  return tab
end
function bit.tonum(bits)
  local num = 0
  for i=1, #bits do
    if bits[i]==1 then
      num = num + 2^(#bits-i)
    end
  end
  return num
end

function system.waitForKey(n)
  while true do
    local _,key = os.pullEvent("key")
    if key==n then return end 
  end 
end
if system.safemode then system.log("Running in safemode.") end

if ...~="-api" then
  if term.isColor() and not ... then
    for i=1, 3 do
  	  sleep(0.15)
  	  term.clear()
      local h = paintutils.loadImage(system.dir.."/logo")
      if i<=2 then
        for _, v in pairs(h) do
      	  for k=1, #v do
      	    if v[k]==1 then
      	  	  v[k]=colors.gray+((i-1)*128)
      	    end
      	  end
        end
      end
      paintutils.drawImage(h, 2, 2)
      term.setBackgroundColor(0x8000)
      term.setTextColor(1)
      print()
      system.writeCenter("by jlortiz\n\n")
    end
  elseif not ... then
  	local h = paintutils.loadImage(system.dir.."/logo")
  	for i=-9, 2 do
  	  sleep(0.1)
  	  term.clear()
  	  paintutils.drawImage(h, 2, i)
  	  term.setBackgroundColor(0x8000)
      term.setTextColor(1)
      system.writeCenter("by jlortiz\n\n")
  	end
  end
  system.log("Played logo animation.")
  print("Press F8 or Fn+F8 to pause startup...")
  if parallel.waitForAny(function() system.waitForKey(66) end, function() sleep(3) end)==1 then
    system.log("User entered advanced startup menu.")
    local n = system.drawMenu({"Continue boot","Start in safemode", "Exit to CraftOS", "Shutdown"}, "Startup paused.\n")
    if n==4 then os.shutdown()
    else
      if n == 1 then shell.run(system.mainFile) 
      elseif n==2 then shell.run(system.mainFile, "-safe") end
      return
    end 
  end
else system.safemode = true
end

h = fs.open(system.dir.."/registry", "r")
local registry = textutils.unserialise(h.readAll())
h.close()
local pass = registry.apass
function system.get(value)
  return textutils.unserialize(textutils.serialize(registry[value]))
end
function system.set(value, new)
  registry[value]=textutils.unserialize(textutils.serialize(new))
end
function system.saveSettings()
  local h = fs.open(system.dir.."/registry", "w")
  h.write(textutils.serialise(registry))
  h.close()
  system.log("Saved registry.")
end

if not system.safemode then
  term.clear()
  term.setCursorPos(1,1)
  for _,v in pairs(fs.list(system.dir.."/startup/")) do
    if not shell.run("/"..system.dir.."/startup/"..v) then
      system.log("Startup script error! File: "..system.dir.."/startup/"..v)
    end
  end
end
if ...=="-api" or system.safemode=="exit" then return end

local function main()
  local n=1
  while true do
    local progs = system.get("programs")
    local active = {}
    for i=1,#progs do
      table.insert(active, progs[i][1])
    end
    table.insert(active, "Exit")
    parallel.waitForAny(function()
      local timer=os.startTimer(60)
      while true do
        local event, data = os.pullEvent()
        if event=="timer" and data==timer then
          system.log("Starting screensaver.")
          os.run({}, system.dir.."/programs/screensaver")
        elseif event=="key" or event=="mouse_click"  or event=="monitor_touch" then
          os.cancelTimer(timer)
          timer = os.startTimer(60)
        end
      end
    end, function()
      n = system.drawMenu(active, "Welcome to SimOS.\nIt is "..textutils.formatTime(os.time(), system.get("24hr")).." on day "..os.day()..".\n", n)
    end)
    if n == #active then
      system.log("User entered shutdown menu.")
      local n=system.drawMenu({"Cancel", "Exit to CraftOS", "Reboot", "Shutdown"}, "Shutdown Menu:\n")
      if n==4 then os.shutdown()
      elseif n==3 then os.reboot()
      elseif n==2 then return end
    else
      system.log("User running "..progs[n][2])
      term.clear()
      term.setCursorPos(1,1)
      local dir = shell.dir()
      shell.setDir(system.dir.."/programs/")
      shell.run(progs[n][2])
      shell.setDir(dir)
      system.log("Returning to SimOS main menu...")
      sleep(system.get("endwait"))
    end 
  end
end
local ok, error = pcall(main)
if not ok then
  system.log("Fatal SimOS error! "..error)
  system.drawMenu({"OK"}, "Sorry, but SimOS has encountered an error and must close.\nThe error is as follows:\n"..error)
end
